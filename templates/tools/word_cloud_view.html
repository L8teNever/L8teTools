{% extends "base.html" %}

{% block title %}{{ cloud.title }}{% endblock %}

{% block content %}
<div class="flex flex-col items-center min-h-[80vh] gap-8">
    <div class="m3-card max-w-[500px] w-full">
        <div class="text-center mb-6">
            <span class="material-icons-round text-6xl text-[var(--m3-primary)] mb-4">cloud_queue</span>
            <h2 class="text-2xl font-bold">{{ cloud.title }}</h2>
            <p class="text-sm opacity-70 mt-2">{{ cloud.description or "Schreibe Begriffe auf, die dir dazu einfallen!"
                }}</p>
        </div>

        <div class="flex gap-2">
            <input type="text" id="wordInput" class="m3-text-input !py-3" placeholder="Dein Begriff..." maxlength="30">
            <button onclick="submitWord()" id="submitBtn" class="m3-button m3-button-filled !w-auto !px-6">
                <span class="material-icons-round">send</span>
            </button>
        </div>
    </div>

    <!-- Word Cloud Display -->
    <div class="m3-card !bg-[var(--m3-surface)] min-h-[500px] w-full max-w-5xl flex items-center justify-center relative overflow-hidden"
        id="cloudContainer">
        <div id="wordCloud" class="relative w-full h-[500px]">
            <!-- Words injected here as absolute elements -->
            <div class="absolute inset-0 flex items-center justify-center">
                <p class="text-[var(--m3-outline)] animate-pulse">Lade Wortwolke...</p>
            </div>
        </div>
    </div>
</div>

<style>
    .cloud-word {
        position: absolute;
        transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        white-space: nowrap;
        transform-origin: center center;
    }

    .cloud-word:hover {
        z-index: 100 !important;
        filter: brightness(1.2);
    }
</style>

<script>
    async function submitWord() {
        const word = document.getElementById('wordInput').value.trim();
        if (!word) {
            showToast('Wort eingeben!');
            return;
        }

        const btn = document.getElementById('submitBtn');
        btn.disabled = true;

        try {
            const response = await fetch('/api/wordcloud/{{ cloud.slug }}/submit', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ word: word, name: 'Anonym' })
            });

            if (response.ok) {
                document.getElementById('wordInput').value = '';
                showToast('Gesendet!');
                loadCloudData();
            } else {
                const res = await response.json();
                showToast(res.error);
            }
        } catch (e) {
            showToast('Fehler beim Senden');
        } finally {
            btn.disabled = false;
        }
    }

    async function loadCloudData() {
        try {
            const response = await fetch('/api/wordcloud/{{ cloud.slug }}/data');
            const data = await response.json();
            renderCloud(data.words);
        } catch (e) {
            console.error('Error loading cloud data:', e);
        }
    }

    function renderCloud(words) {
        const container = document.getElementById('wordCloud');
        if (!words || words.length === 0) {
            container.innerHTML = '<div class="absolute inset-0 flex items-center justify-center text-[var(--m3-outline)]">Noch keine WÃ¶rter vorhanden.</div>';
            return;
        }

        const syncId = JSON.stringify(words.map(w => ({ t: w.text, s: w.size })));
        if (container.getAttribute('data-sync') === syncId) return;
        container.setAttribute('data-sync', syncId);

        container.innerHTML = '';

        const maxCount = Math.max(...words.map(w => w.size));
        const minCount = Math.min(...words.map(w => w.size));

        const colors = [
            '#6750A4', '#9333ea', '#db2777', '#dc2626', '#ea580c',
            '#0284c7', '#16a34a', '#0891b2', '#4f46e5', '#7d5260'
        ];

        // Sort by size descending to place larger words more central
        words.sort((a, b) => b.size - a.size);

        const centerX = container.offsetWidth / 2;
        const centerY = container.offsetHeight / 2;

        words.forEach((word, index) => {
            let fontSize = 1;
            if (maxCount === minCount) {
                fontSize = 1.6;
            } else {
                fontSize = 1.1 + (word.size - minCount) / (maxCount - minCount) * 2.8;
            }

            const span = document.createElement('span');
            span.className = 'cloud-word font-bold animate-fade-in';
            span.textContent = word.text;
            span.style.fontSize = fontSize + 'rem';

            // Deterministic hash for color/rotation
            let hash = 0;
            for (let i = 0; i < word.text.length; i++) hash = word.text.charCodeAt(i) + ((hash << 5) - hash);
            span.style.color = colors[Math.abs(hash) % colors.length];

            // Radial distribution algorithm
            // We use the index to spiral outwards
            const angle = index * 2.4; // Golden angle-ish
            const radius = index === 0 ? 0 : 35 + (index * 15);

            // Add some "organic" jitter based on the hash
            const jitterX = (Math.abs(hash % 40) - 20);
            const jitterY = (Math.abs((hash >> 3) % 40) - 20);

            const x = centerX + (Math.cos(angle) * radius) + jitterX;
            const y = centerY + (Math.sin(angle) * radius) + jitterY;

            // Rotation also deterministic
            const rotate = (Math.abs(hash % 20) - 10);

            span.style.left = `calc(${x}px - 2rem)`; // Rough offset for centering the text block
            span.style.top = `calc(${y}px - 1rem)`;
            span.style.transform = `rotate(${rotate}deg)`;
            span.style.zIndex = words.length - index;
            span.title = `${word.size}x genannt`;

            container.appendChild(span);
        });
    }

    // Handle Enter
    document.getElementById('wordInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitWord();
    });

    loadCloudData();
    setInterval(loadCloudData, 3000);
</script>
{% endblock %}